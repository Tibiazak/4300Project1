# Joshua Bearden
# CS4300 Project 1
# 2/19/18
# Written in Python 3.6.4
#
# A program to solve the missionaries and cannibals problem using iterative deepening search
#
# This program uses methods:
# performop which takes a state (represented by a list of 3 integers) and an operation to perform on that state
# (which is also represented by a list of 3 integers), and it returns the new state generated by the operation.
#
# isvalid takes in a state and the starting state of the problem, and checks if the state is valid.
# It returns either true or false.
#
# gensuccessors takes in a list of operations, the current state, and the start state. It performs every
# operation in the operations list on the current state, checks each one to ensure it's valid, and returns
# two lists: one with the valid successors, and one with the operations used to get there.
#
# search takes in a state, the current max depth, a goal state, a list of operations, and the start state.
# This is a recursive function that checks for the goal, and if it doesn't find it, it recursively calls
# itself until it either finds the goal or reaches the max depth. It returns either None (null) or, if it
# finds the goal, each call to search appends the operation it used to generate the node for the call below it
# to a list, and finally returns that list to the main program.
#
# showresult simply takes in the start state and a list of operations performed, and prints out each state
# visited in order by performing the operations necessary to reach the states, going from start state to goal.
# It returns nothing.


# A function to perform an operation on a state
def performop(state, op):
    newstate = list.copy(state)  # Generates a copy of the original state to prevent side effects
    # Iterates through each item in both lists, either adding (if the boat is on the other side of the river)
    # or subtracting (if the boat is on our side of the river) the operation values from the state values.
    for i in range(0, 3):
        if state[2] == 1:
            newstate[i] = newstate[i] - op[i]
        else:
            newstate[i] = newstate[i] + op[i]
    return newstate  # return the new state we made


# A function to check if a given state is valid
def isvalid(state, startstate):
    otherside = startstate.copy()  # Copy our starting state to prevent side effects

    # Subtract our current state from the start state to generate the state of the other side of the river
    for i in range(0, 3):
        otherside[i] = startstate[i] - state[i]

    # If the cannibals outnumber the missionaries (and there are missionaries on this side): fail
    if (state[1] > state[0]) and state[0] != 0:
        return False
    # If there are more cannibals or missionaries than we started with; or a second boat appeared: fail.
    elif state[0] > 3 or state[1] > 3 or state[2] > 1:
        return False
    # If the cannibals outnumber the missionaries on the other side (and there are missionaries): fail
    elif (otherside[1] > otherside[0]) and otherside[0] != 0:
        return False
    # If there are more cannibals or missionaries or boats than we started with on the other side: fail
    elif otherside[0] > 3 or otherside[1] > 3 or otherside[2] > 1:
        return False
    # If we get here, the state is valid, return True
    else:
        return True


# A function to generate all the successors of a state
def gensuccessors(ops, state, startstate):
    # Create our lists to be appended to
    successors = []
    validops = []

    # Go through every operation in our list of operations and perform it on our current state
    for op in ops:
        new = performop(state, op)
        # Check if the new state is valid, if it is then append it to our list of valid successors
        # and append the operation to our list of valid operations. Otherwise, do nothing, continue the loop.
        if isvalid(new, startstate):
            successors.append(new)
            validops.append(op)
    # Return the lists of valid successors and operations.
    return successors, validops


# A function to perform depth first search to a given max depth
def search(node, depth, goal, ops, startstate):
    # If our current node is a goal, return an empty list
    if node == goal:
        return []
    # Otherwise, if we can go deeper, generate valid successors and search each one
    elif depth > 0:
        transitions, valops = gensuccessors(ops, node, startstate)
        for state in transitions:
            result = search(state, depth-1, goal, ops, startstate)
            # For each state we search, result will eventually either be null or be a list of operations
            # If it is a list, append the operation used to get to that state to our result list.
            # If it is null, check the next state
            if result is not None:
                result.append(valops[transitions.index(state)])
                return result
        # If we get here, we've checked all the states and none worked, return null
        return None
    # If we can't go deeper, and this isn't the goal, return null.
    else:
        return None


# A function to print out the results of our search
def showresult(start, ops):
    # Print the solution depth and starting state
    print("Solution found at depth " + str(len(ops)) + "!")
    print("S0: " + str(start))
    state = start.copy()  # copy the start state to prevent side effects
    # For each item in our list of operations, perform that operation on the current state
    # then print it out.
    for i in range(0, len(ops)):
        for j in range(0, 3):
            if state[2] is 1:
                state[j] -= ops[i][j]
            else:
                state[j] += ops[i][j]
        print("S" + str(i+1) + ": " + str(state))
    return


# Initiate variables - startstate is 3 missionaries, 3 cannibals, and a boat
# goalstate is 0 missionaries, 0 cannibals, no boat
# operations is a list of all the possible operations we can perform on a state
# found is used so we can print a failure message
startstate = [3, 3, 1]
goalstate = [0, 0, 0]
operations = [[0, 1, 1], [1, 0, 1], [1, 1, 1], [2, 0, 1], [0, 2, 1]]
found = False

# initialize maxdepth to an empty string, then get input and check to ensure valid integer input
maxdepth = ''
while not maxdepth.isdigit():
    maxdepth = input("Please enter the maximum depth to search to: ")
    if not maxdepth.isdigit():
        print("Error! Integer required.")
# once input is valid, convert to an int
maxdepth = int(maxdepth)

# A for loop to perform the iterative deepening part of the search.
# Calls search with every integer from 0 to the max depth given by the user, until it either returns a solution
# or we hit the max depth with no solution.
for i in range(0, maxdepth):
    result = search(startstate, i, goalstate, operations, startstate)
    # If we get a solution, reverse the list (since it was appended back to front) and print the statistics
    # setting found to True and breaking out of our for loop.
    if result is not None:
        result.reverse()
        showresult(startstate, result)
        found = True
        break
# If we finish the for loop and haven't found a solution, print failure and the depth attempted.
if not found:
    print("Goal state not found at depth ", str(maxdepth))
